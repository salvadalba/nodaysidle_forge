# Architecture Requirements Document

## üß± System Overview
Forge is a macOS-native code editor built entirely on Apple frameworks, combining GPU-accelerated Metal shader rendering at 120fps, on-device CoreML semantic indexing, and SwiftData local-first persistence. The architecture is a single-process native app with no server component, leveraging Swift Structured Concurrency to orchestrate parallel subsystems (rendering, language servers, file watchers, AI indexing) within one macOS application target. All AI inference runs on-device via CoreML and the NaturalLanguage framework, ensuring full offline capability and data privacy.

## üèó Architecture Style
Monolithic native macOS application using layered architecture with four primary layers: Presentation (SwiftUI 6 views with Metal shader rendering), State (Observation framework reactive models), Domain (editor logic, LSP orchestration, semantic indexing), and Persistence (SwiftData local store with optional CloudKit sync). Layers communicate through Swift protocols and the Observation framework, with Structured Concurrency managing all asynchronous coordination.

## üé® Frontend Architecture
- **Framework:** SwiftUI 6 targeting macOS 15+ (Sequoia). Views use TimelineView for GPU-accelerated Metal shader text rendering and UI compositing at 120fps on ProMotion displays. NSWindow customization provides titlebar styling and .ultraThinMaterial / .regularMaterial vibrancy for premium native chrome. matchedGeometryEffect drives fluid tab switching transitions, PhaseAnimator powers sidebar reveal and command palette animations. WindowGroup and Settings scenes provide standard macOS window and preferences management. Menu bar integration uses SwiftUI Commands API.
- **State Management:** Observation framework (@Observable) for all editor state models including document buffers, workspace configuration, sidebar state, and command palette context. Observable models are injected into SwiftUI views via @Environment and @Bindable, providing efficient fine-grained view updates without manual publisher wiring. No third-party state management libraries. Editor document state uses value types where possible to leverage SwiftUI diffing, with reference-type @Observable wrappers for shared mutable state like the active workspace and open tabs.
- **Routing:** Single-window architecture with SwiftUI NavigationSplitView for sidebar/detail layout. Command palette overlay presented as a .sheet or custom ZStack overlay with matched geometry transitions. Tab bar manages open editor buffers as an @Observable TabGroup model. Settings scene uses a dedicated SwiftUI Settings window. No URL-based routing ‚Äî all navigation is in-process view state transitions driven by Observation model changes.
- **Build Tooling:** Swift Package Manager (SwiftPM) as the sole build system. The project is structured as a SwiftPM package with targets for the main app, editor engine, semantic indexer, and shared models. CoreML models are bundled as SPM resources. No Xcode project file dependency ‚Äî the Package.swift is the source of truth. Xcode is used as the IDE but builds are reproducible via swift build from the command line.

## üß† Backend Architecture
- **Approach:** No server backend. All logic runs locally within the macOS application process. The 'backend' is the domain layer of the native app, organized as Swift modules within the SwiftPM package. Structured Concurrency (async/await, TaskGroup, AsyncStream) orchestrates all parallel subsystems. Each major subsystem (LSP client, file watcher, semantic indexer, persistence) runs as a long-lived Task coordinated through actors to prevent data races.
- **API Style:** No network API. Internal communication uses Swift protocols and async method calls between actor-isolated services. The LSPCoordinator communicates with external language servers via JSON-RPC over stdin/stdout process pipes. The semantic indexer and persistence layer communicate through SwiftData model objects and AsyncStream event channels. All inter-module boundaries are defined by Swift protocol interfaces for testability.
- **Services:**
- MetalRenderingEngine: TimelineView-based Metal shader pipeline for GPU-accelerated text rendering, glyph caching, syntax highlighting compositing, and 120fps frame scheduling. Delegates complex Unicode and ligature layout to Core Text, composites results via Metal.
- SemanticIndexer: Actor-isolated service that runs CoreML inference and NaturalLanguage framework tokenization to build semantic embeddings for source files. Processes files incrementally using AsyncStream from the file watcher. Writes index data to SwiftData on a background ModelContext.
- LSPCoordinator: Manages multiple Language Server Protocol client connections as child Tasks within a TaskGroup. Translates LSP JSON-RPC over stdin/stdout using AsyncBytes streams. Provides completions, diagnostics, and go-to-definition results to the editor state layer.
- FileWatcher: Wraps DispatchSource.makeFileSystemObjectSource and FSEvents to emit file change events as an AsyncStream. Feeds the semantic indexer and refreshes the file tree sidebar. Debounces rapid changes to avoid redundant processing.
- PersistenceManager: SwiftData ModelContainer and ModelContext management. Runs background saves on a dedicated ModelContext off the main actor. Handles workspace state, recent files, editor preferences, and semantic index storage. Optional CloudKit sync zone for preferences only.
- WorkspaceManager: @Observable model that coordinates opening, closing, and switching workspaces. Owns the file tree, tab group, and active document references. Serves as the root state object injected into the SwiftUI environment.

## üóÑ Data Layer
- **Primary Store:** SwiftData with a local SQLite backing store. ModelContainer is configured with a single persistent store at ~/Library/Application Support/Forge/. Three schema domains: (1) WorkspaceState ‚Äî open tabs, sidebar layout, window positions, recent files; (2) SemanticIndex ‚Äî file embeddings, symbol tables, token vectors keyed by file path and content hash; (3) EditorPreferences ‚Äî themes, keybindings, font settings. Background ModelContext instances handle writes off the main actor to prevent frame drops. Optional CloudKit sync is scoped to EditorPreferences only via a separate CloudKit-enabled ModelConfiguration.
- **Relationships:** WorkspaceState has a one-to-many relationship with OpenDocument entries. SemanticIndex entries reference files by path and content hash (not foreign keys to workspace) for decoupled index invalidation. EditorPreferences is a singleton record per preference category. No cross-domain relationships ‚Äî domains are intentionally isolated to allow independent migration and background processing without contention.
- **Migrations:** SwiftData lightweight migration via VersionedSchema. Each schema domain declares explicit schema versions. Additive changes (new attributes, new models) use automatic lightweight migration. Destructive changes (removed attributes, type changes) require a SchemaMigrationPlan with explicit MigrationStage definitions. The semantic index schema is designed as rebuildable ‚Äî on incompatible migration, the index is dropped and rebuilt from source files rather than migrated.

## ‚òÅÔ∏è Infrastructure
- **Hosting:** No server hosting. Forge is distributed as a signed and notarized macOS application bundle (.app). Distribution channels: direct download DMG from project website and optionally the Mac App Store. The app is fully self-contained with bundled CoreML models, no external service dependencies, and no backend infrastructure to provision.
- **Scaling Strategy:** Single-user local application ‚Äî no horizontal scaling. Performance scaling is vertical via Apple silicon GPU and Neural Engine utilization. The semantic indexer scales across CPU cores using TaskGroup parallelism with a concurrency limit matching the machine's performance core count. Metal rendering scales with GPU capabilities. SwiftData handles dataset growth through SQLite's B-tree indexing. For very large codebases (>100K files), the semantic indexer uses incremental processing with content-hash-based cache invalidation to avoid full re-indexing.
- **CI/CD:** GitHub Actions with macOS runners for CI. Build step: swift build via SwiftPM. Test step: swift test for unit and integration tests. Lint step: SwiftLint via SPM plugin. Notarization step: xcodebuild archive followed by notarytool submit for signed builds. Release artifacts are DMG disk images created via create-dmg or hdiutil. No container-based deployment. Versioning follows semantic versioning with Git tags triggering release builds.

## ‚öñÔ∏è Key Trade-offs
- macOS-only at launch sacrifices cross-platform reach for native rendering performance and Apple framework integration ‚Äî future cross-platform expansion will require a separate rendering layer or Swift-on-Linux strategy, not addressed in this architecture
- SwiftUI 6 Metal shader rendering provides GPU acceleration but may hit limitations with complex Unicode, bidirectional text, and ligature rendering that Core Text handles natively ‚Äî the architecture delegates these cases to Core Text and composites via Metal rather than reimplementing text shaping
- Single-process monolithic architecture is simpler to build and debug than multi-process (like VS Code's extension host model) but means a crash in any subsystem (LSP client, indexer) could take down the editor ‚Äî mitigated by actor isolation and structured task cancellation rather than process boundaries
- SwiftData over raw SQLite sacrifices fine-grained query control for framework integration with SwiftUI and automatic background sync ‚Äî acceptable because the data model is straightforward and the semantic index is designed as rebuildable
- Bundling CoreML models in the app binary increases download size but eliminates network dependency and ensures offline functionality ‚Äî model size must be monitored and compressed formats preferred
- Observation framework over Combine simplifies state management and eliminates boilerplate but requires macOS 14+ (met by the macOS 15 minimum target) ‚Äî no migration path needed since this is a greenfield project
- No plugin/extension API at launch reduces architectural complexity and attack surface but limits community contributions ‚Äî the internal module boundary design via Swift protocols preserves the option to expose a plugin API in future releases

## üìê Non-Functional Requirements
- 120fps rendering during editing, scrolling, and animations on Apple silicon Macs with ProMotion displays, verified via Instruments Metal System Trace
- Cold launch to interactive editor in under 2 seconds on M1 or later hardware, measured from process start to first editable frame
- Semantic index build for a 100K-line codebase completes within 30 seconds using on-device CoreML inference on the Neural Engine
- Memory usage stays below 500MB for workspaces with up to 50K files, with a target of under 300MB for typical 10K-file workspaces
- Keystroke-to-render latency below 8ms to ensure imperceptible input lag during editing
- All AI inference and code analysis executes on-device with zero network calls ‚Äî fully functional offline
- SwiftData background saves must not block the main thread or cause frame drops, verified via Instruments hang detection with a 100ms hang threshold
- Minimum deployment target: macOS 15 (Sequoia) on Apple silicon (M1 or later)
- App binary signed with Developer ID and notarized for Gatekeeper compatibility
- Structured Concurrency task cancellation must propagate cleanly ‚Äî no orphaned tasks or leaked file handles when closing workspaces or quitting the app